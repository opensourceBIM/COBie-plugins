/**
 * Dbs.java
 *
 * This file was generated by MapForce 2014r2.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */

package com.altova.db;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import com.altova.mapforce.IEnumerable;
import com.altova.mapforce.IEnumerator;
import com.altova.mapforce.MFEmptySequence;
import com.altova.mapforce.MFSingletonSequence;
import com.altova.mapforce.SequenceFactory;

import com.altova.functions.Core;

import com.altova.types.CalendarBase;
import com.altova.types.DateTime;
import com.altova.types.Duration;
import com.altova.types.StringParseException;

public class Dbs 
{
	static class ForceOne implements IEnumerable
	{
		Object obj;
		
		public ForceOne(IEnumerable s) throws Exception
		{
			com.altova.mapforce.IEnumerator en = s.enumerator();
			try {
				if (en.moveNext()) 
					obj = en.current();
			} finally {
				en.close();
			}
		}

		static class InfiniteEnumerator implements com.altova.mapforce.IEnumerator
		{
			Object obj;
			int position;
			public InfiniteEnumerator(Object obj) { this.obj = obj; }
			public boolean moveNext() { ++position; return true; }
			public Object current() { return obj; }
			public int position() { return position; }
			public void close() {}
		}

		static class EmptyEnumerator implements com.altova.mapforce.IEnumerator
		{
			public EmptyEnumerator() {}
			public boolean moveNext() { return false; }
			public Object current() { return null; }
			public int position() { return 0; }
			public void close() {}
		}

		public com.altova.mapforce.IEnumerator enumerator() 
		{
			if (obj != null) return new InfiniteEnumerator(obj);
			else return new EmptyEnumerator();
		}
	}

	public static void writeField(Record record, String field, IEnumerable value) throws Exception
	{
		record.fields.put(field, new ForceOne(value));
	}

	static public void addChildren(Record record, String field, IEnumerable children)
	{
		record.children.put(field, children);
	}

	static public IEnumerable getChildren(Record record, String field)
	{
		return record.children.get(field);
	}

	public static IEnumerable readField(Record record, String name)
	{
		if (!record.fields.containsKey(name))
			throw new UnsupportedOperationException("Column \"" + name + "\" not found in record"); 
			
		return record.fields.get(name);
	}

	public static void bindParameter_empty(Statement command)
	{
		command.bindParameter(null);
	}
	
	public static void bindParameter_String(Statement command, String value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_BigDecimal(Statement command, BigDecimal value) throws Exception
	{
		command.bindParameter(value, value.scale());
	}
	
	public static void bindParameter_DateTime(Statement command, DateTime value) throws Exception
	{
		value.setTimezoneOffset(0);// cut off tz
		java.util.Calendar cal = java.util.Calendar.getInstance();
		long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
		long millisec = value.getValue().getTimeInMillis();
		java.sql.Timestamp ts = new java.sql.Timestamp(millisec);
		ts.setTime( ts.getTime() - tzoffset );// cut local tz
		ts.setNanos((int)(value.getPartSecond() * 1000000000));
		command.bindParameter(ts);
	}
	
	public static void bindParameter_DateTimeTZ(Statement command, DateTime value) throws Exception
	{
		long millisec = value.getValue().getTimeInMillis();
		java.sql.Timestamp ts = new java.sql.Timestamp(millisec);
		command.bindParameter(ts);
	}

	public static void bindParameter_Time(Statement command, DateTime value) throws Exception
	{
		value.setTimezoneOffset(0);// cut off tz
		value.setYear(1970); value.setMonth(1); value.setDay(1);
		java.util.Calendar cal = java.util.Calendar.getInstance();
		long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
		long ms = value.getValue().getTimeInMillis();
		java.sql.Time time = new java.sql.Time(ms);
		time.setTime( time.getTime() - tzoffset );
		command.bindParameter(time);
	}

	public static void bindParameter_TimeTZ(Statement command, DateTime value) throws Exception
	{
		value.setYear(1970); value.setMonth(1); value.setDay(1);
		long ms = value.getValue().getTimeInMillis();
		java.sql.Time time = new java.sql.Time(ms);
		command.bindParameter(time);
	}

	public static void bindParameter_long(Statement command, long value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_int(Statement command, int value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_boolean(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_binary(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_BigInteger(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_double(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	

	public static void bindParameter_IntervalDaySecond(Statement command, Duration duration) throws Exception
	{
		StringBuilder s = new StringBuilder();
		if (duration.isNegative())
			s.append("-");
		else
			s.append("+");

		s.append(java.lang.Math.abs(duration.getDay()));
		s.append(" ");
		s.append(java.lang.Math.abs(duration.getHour()));
		s.append(":");
		s.append(java.lang.Math.abs(duration.getMinute()));
		s.append(":");
		
		double seconds = java.lang.Math.abs(duration.getSecond())
					   + java.lang.Math.abs(duration.getPartSecond());
		DecimalFormatSymbols symbols = new DecimalFormatSymbols(java.util.Locale.US);
		DecimalFormat formatter = new DecimalFormat("00.0###############", symbols);
		s.append(formatter.format(seconds));
		
		command.bindParameter(s.toString());
	}

	public static void bindParameter_IntervalYearMonth(Statement command, Duration duration) throws Exception
	{
		StringBuilder s = new StringBuilder();
		if (duration.isNegative())
			s.append("-");
		else
			s.append("+");

		s.append(java.lang.Math.abs(duration.getYear()));
		s.append("-");
		s.append(java.lang.Math.abs(duration.getMonth()));
				
		command.bindParameter(s.toString());
	}
	
	public static void bindParameter_money_PostgreSQL(Statement command, Double value) throws Exception
	{
		// with the JdbcOdbc bridge the value is correctly converted to money types when adding it as BigDecimal.
		// when using the PostgreSQL JDBC Interface you'll get a cast error (numeric to money) when binding with DECIMAL type. 
		command.bindParameter(value != null ? value.toString() : null); // transfer as string 
	}

	public static void bindParameter_nchar_SQLServer(Statement command, String value) throws Exception
	{
		if( checkForJdbcOdbcConnection(command.getConnection()) ) 
		{// fix for SQLServer nchar, nvarchar
			int i = command.getValues().size();
			command.setParameterType(i, java.sql.Types.BINARY);
			command.bindParameter(java.nio.charset.Charset.forName("UTF-16LE").encode(value).array());
		}
		else
		{
			bindParameter_String( command, value );			
		}
	}

	public static void bindParameter_nchar_Sybase(Statement command, String value) throws Exception
	{
		if(value.length() > 0 )
		{
			int i = command.getValues().size();
			command.setParameterType(i, java.sql.Types.BINARY);
			command.bindParameter(java.nio.charset.Charset.forName("ISO-8859-1").encode(value).array());
		}
		else
		{
			int i = command.getValues().size();
			command.setParameterType(i, java.sql.Types.VARCHAR);
			command.bindParameter( value );
		}
	}
	
	public static void bindParameter_BigDecimal_SQLServer(Statement command, BigDecimal value) throws Exception
	{
		if( value.scale() >= 60 ) 
		{// driver has problems with large scale decimals 
			value = value.stripTrailingZeros();
		}
		command.bindParameter(value, value.scale());
	}

	public static void bindParameter_DateTimeOffset_SQLServer(Statement command, DateTime value) throws Exception
	{
		command.bindParameter(value.toString());
	}

	public static void bindParameter_Graphic_DB2(Statement command, String value) throws Exception
	{
		command.bindParameter(value,0);
	}

	public static void bindParameter_char_Oracle(Statement command, String value)
	{
		Statement.Parameter parameter = command.getParameter(command.getValues().size());
		if( parameter != null && parameter.type == java.sql.Types.CHAR && parameter.scaleOrLength > value.length() )
		{
			value = String.format("%1$-" + parameter.scaleOrLength + "s", value);  
		}
		command.bindParameter(value);
	}

	public static void bindParameter_BigDecimal_Oracle(Statement command, BigDecimal value) throws Exception
	{
		if( (checkForJdbcOdbcConnection(command.getConnection())) )
		{
			value = value.stripTrailingZeros();
			String s = value.toPlainString();
			value = new BigDecimal(s);
		}
		command.bindParameter(value, value.scale());
	}

	public static void bindParameter_IntervalDaySecond_Oracle(Statement command, Duration duration) throws Exception
	{
		bindParameter_IntervalDaySecond(command, duration);
	}

	public static void bindParameter_IntervalYearMonth_Oracle(Statement command, Duration duration) throws Exception
	{
		bindParameter_IntervalYearMonth(command, duration);
	}

	public static void bindParameter_Interval_PostgreSQL(Statement command, Duration duration) throws Exception
	{
		StringBuilder s = new StringBuilder();

		s.append(duration.getYear());
		s.append(" year ");
		s.append(duration.getMonth());
		s.append(" month ");
		s.append(duration.getDay());
		s.append(" day ");

		if((duration.getHour() < 0)
		|| (duration.getMinute() < 0)
		|| (duration.getSecond() < 0)
		|| (duration.getPartSecond() < 0.0))
		{
			s.append("-");
			duration.setNegative(false);
		}
			
		s.append(duration.getHour());
		s.append(":");
		s.append(duration.getMinute());
		s.append(":");
		s.append(duration.getSecond() + duration.getPartSecond());
		
		command.bindParameter(s.toString());	
	}

	public static void bindParameter_DateTimeTZ_PostgreSQL(Statement command, DateTime value) throws Exception
	{
		StringBuffer s = new StringBuffer();
		s.append( value.toDateString() );
		s.append(" ");
		s.append( value.toTimeString() );
		command.bindParameter(s.toString());
	}
	
	public static void bindParameter_Unicode_PostgreSQL(Statement command, String value) throws Exception
	{
		// when using JdbcOdbc with extended unicode characters  
		java.nio.charset.Charset cs = java.nio.charset.Charset.forName("UTF-8");
		java.nio.ByteBuffer bb = cs.encode(value);
		byte[] buf = new byte[bb.limit()];
		for(int i=0; i<bb.limit(); ++i)
			buf[i]=bb.get(i);
		
		command.bindParameter( buf, buf.length );
	}

	public static void bindParameter_BigInteger_MySQL(Statement command, Object value) throws Exception
	{
		if( (checkForJdbcOdbcConnection(command.getConnection()))
		&&  (command.getConnection().getMetaData().getDriverName().contains("myodbc3")) )
		{// fix for MySQL Driver 3.51 with unsigned bigint types
			command.bindParameter(value.toString());
		}
		else
		{// ODBC Driver 5.1 and Connector/J
			command.bindParameter(value);
		}
	}
	
	public static void bindParameter_char_Informix(Statement command, String value) throws Exception
	{
		int parameterType = ( checkForJdbcOdbcConnection(command.getConnection()) ) ? java.sql.Types.VARCHAR : java.sql.Types.CHAR;
		command.setParameterType(command.getValues().size(), parameterType );// jdbcodbc bridge triggers an error when parameter is char

		bindParameter_String(command, value);
	}
	
	public static void bindParameter_varchar_Informix(Statement command, String value) throws Exception
	{
		int parameterType = ( checkForJdbcOdbcConnection(command.getConnection()) ) ? java.sql.Types.VARCHAR : java.sql.Types.LONGVARCHAR;
		command.setParameterType(command.getValues().size(), parameterType );// jdbcodbc bridge triggers an error when parameter is longvarchar

		bindParameter_String(command, value);
	}
	
	public static void bindParameter_blob_Informix(Statement command, Object value)
	{
		command.bindParameter(new java.io.ByteArrayInputStream((byte[])value));
	}
	
	public static void bindParameter_clob_Informix(Statement command, String value)
	{
		command.bindParameter(new java.io.StringReader(value));
	}

	public static final int DurationPart_Year = 1 << 0;
	public static final int DurationPart_Month = 1 << 1;
	public static final int DurationPart_Day = 1 << 2;
	public static final int DurationPart_Hour = 1 << 3;
	public static final int DurationPart_Minute = 1 << 4;
	public static final int DurationPart_Second = 1 << 5;
	public static final int DurationPart_Fraction = 1 << 6;
	
	public static void read_DateTimeYearToYear_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Year);
	}
	public static void read_DateTimeMonthToMonth_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Month);
	}
	public static void read_DateTimeMonthToDay_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day);
	}
	public static void read_DateTimeMonthToHour_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour);
	}
	public static void read_DateTimeMonthToMinute_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
	}
	public static void read_DateTimeMonthToSecond_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
	}
	public static void read_DateTimeMonthToFraction_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
	}
	public static void read_DateTimeDayToDay_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Day);
	}
	public static void read_DateTimeDayToHour_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour);
	}
	public static void read_DateTimeDayToMinute_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
	}
	public static void read_DateTimeDayToSecond_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
	}
	public static void read_DateTimeDayToFraction_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
	}
	public static void read_DateTimeHourToHour_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour);
	}
	public static void read_DateTimeHourToMinute_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute);
	}
	public static void read_DateTimeHourToSecond_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
	}
	public static void read_DateTimeHourToFraction_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
	}
	public static void read_DateTimeMinuteToMinute_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Minute);
	}
	public static void read_DateTimeMinuteToSecond_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Minute|DurationPart_Second);
	}
	public static void read_DateTimeMinuteToFraction_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
	}
	public static void read_DateTimeSecondToSecond_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Second);
	}
	public static void read_DateTimeSecondToFraction_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Second|DurationPart_Fraction);
	}
	public static void read_DateTimeFractionToFraction_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime_Informix(record, recordset, name, column, DurationPart_Fraction);
	}

	public static void read_DateTime_Informix(Record record, ResultSetWrapper recordset, String name, int column, int parts) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Duration.RefInt n = new Duration.RefInt(0);
		str = str.trim();// strip leading/trailing white spaces
		CalendarBase.ParseContext context = new Duration.ParseContext(str);
		String err = str + " cannot be converted to a datetime value.";
		if (!context.isValid()) throw new StringParseException(err,2);

		int year = 1200;
		int month = 1;
		int day = 1; 
		int hour = 0;
		int minute = 0;
		int second = 0;
		double fraction = 0.0;
		
		if( (parts & DurationPart_Year) == DurationPart_Year ) {
			year = 0;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { year = (year * 10) + n.value; n.value = 0; }
		}
		if(((parts & (DurationPart_Year|DurationPart_Month)) == (DurationPart_Year|DurationPart_Month)) ) {
			if(!context.checkAndAdvance('-')) throw new StringParseException(err,2);
		}
		if( (parts & DurationPart_Month) == DurationPart_Month ) {
			month = 0;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }
		}
		if(((parts & (DurationPart_Month|DurationPart_Day)) == (DurationPart_Month|DurationPart_Day)) ) {
			if(!context.checkAndAdvance('-')) throw new StringParseException(err,2);
		}
		if( (parts & DurationPart_Day) == DurationPart_Day ) {
			day = 0;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { day = (day * 10) + n.value; n.value = 0; }
		}
		if(((parts & (DurationPart_Day|DurationPart_Hour)) == (DurationPart_Day|DurationPart_Hour)) ) {
			if(!context.checkAndAdvance(' ')) throw new StringParseException(err,2);
		}
		if( (parts & DurationPart_Hour) == DurationPart_Hour ) {
			hour = 0;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { hour = (hour * 10) + n.value; n.value = 0; }
		}
		if(((parts & (DurationPart_Hour|DurationPart_Minute)) == (DurationPart_Hour|DurationPart_Minute)) ) {
			if(!context.checkAndAdvance(':')) throw new StringParseException(err,2);
		}
		if( (parts & DurationPart_Minute) == DurationPart_Minute ) {
			minute = 0;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { minute = (minute * 10) + n.value; n.value = 0; }
		}
		if(((parts & (DurationPart_Minute|DurationPart_Second)) == (DurationPart_Minute|DurationPart_Second)) ) {
			if(!context.checkAndAdvance(':')) throw new StringParseException(err,2);
		}
		if( (parts & DurationPart_Second) == DurationPart_Second ) {
			second = 0;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { second = (second * 10) + n.value; n.value = 0; }
		}
		if( (parts & DurationPart_Fraction) == DurationPart_Fraction ) {
			if( context.checkAndAdvance('.') )
			{
				int temp = 0; 
				int start = context.index();
				if(!context.isValid()) throw new StringParseException(str,2);
				while (context.readDigitAndAdvance(n, 1, 9)) { temp = (temp * 10) + n.value; n.value = 0; }
				int end = context.index();
				fraction = temp / Math.pow( 10, end-start );
			}
		}

		com.altova.types.DateTime val = new com.altova.types.DateTime(year,month,day,hour,minute,second,fraction);
		record.fields.put(name, new MFSingletonSequence(val));
	}
	
	public static void bindParameter_DateTime_Informix(Statement command, DateTime value) throws Exception
	{
		value.setTimezoneOffset(0);// cut off tz
		int year = value.getYear();
		int month = value.getMonth();
		int day = value.getDay();
		int hour = value.getHour();
		int minute = value.getMinute();
		int second = value.getSecond();
		java.util.Calendar cal = java.util.Calendar.getInstance();
		long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
		cal.set(java.util.Calendar.ZONE_OFFSET, 0);
		cal.set(java.util.Calendar.DST_OFFSET, 0);
		cal.set( year, month-1, day, hour, minute, second);
		long millisec = cal.getTimeInMillis() - tzoffset;
		java.sql.Timestamp ts = new java.sql.Timestamp(millisec);
		ts.setNanos((int)(value.getPartSecond() * 1000000000));
		command.bindParameter(ts);
	}
	
	public static void bindParameter_IntervalYearYear_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Year);
	}
	public static void bindParameter_IntervalYearMonth_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_IntervalYearMonth(command, duration);// base implementation
	}
	public static void bindParameter_IntervalMonthMonth_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, new Duration(0,java.lang.Math.abs(duration.getYearMonthValue()),0,0,0,0,0.0,duration.isNegative()), DurationPart_Month);
	}
	public static void bindParameter_IntervalDayDay_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Day);
	}
	public static void bindParameter_IntervalDayHour_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Day|DurationPart_Hour);
	}
	public static void bindParameter_IntervalDayMinute_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
	}
	public static void bindParameter_IntervalDaySecond_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
	}
	public static void bindParameter_IntervalDayFraction_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_IntervalDaySecond(command, duration);// base implemetation
	}
	public static void bindParameter_IntervalHourHour_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Hour);
	}
	public static void bindParameter_IntervalHourMinute_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Hour|DurationPart_Minute);
	}
	public static void bindParameter_IntervalHourSecond_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
	}
	public static void bindParameter_IntervalHourFraction_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
	}
	public static void bindParameter_IntervalMinuteMinute_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Minute);
	}
	public static void bindParameter_IntervalMinuteSecond_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Minute|DurationPart_Second);
	}
	public static void bindParameter_IntervalMinuteFraction_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
	}
	public static void bindParameter_IntervalSecondSecond_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Second);
	}
	public static void bindParameter_IntervalSecondFraction_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Second|DurationPart_Fraction);
	}
	public static void bindParameter_IntervalFractionFraction_Informix(Statement command, Duration duration) throws Exception
	{
		bindParameter_Interval_Informix(command, duration, DurationPart_Fraction);
	}

	public static void bindParameter_Interval_Informix(Statement command, Duration duration, int parts) throws Exception
	{
		StringBuilder s = new StringBuilder();
		if (duration.isNegative())
			s.append("-");

		if( (parts & DurationPart_Year) == DurationPart_Year )
			s.append(java.lang.Math.abs(duration.getYear()));
		if(((parts & DurationPart_Year) == DurationPart_Year) && ((parts & DurationPart_Month) == DurationPart_Month) )
			s.append("-");
		if( (parts & DurationPart_Month) == DurationPart_Month )
			s.append(java.lang.Math.abs(duration.getMonth()));
		if(((parts & DurationPart_Month) == DurationPart_Month) && ((parts & DurationPart_Day) == DurationPart_Day) )
			s.append("-");
		if( (parts & DurationPart_Day) == DurationPart_Day )
			s.append(java.lang.Math.abs(duration.getDay()));
		if(((parts & DurationPart_Day) == DurationPart_Day) && ((parts & DurationPart_Hour) == DurationPart_Hour) )
			s.append(" ");
		if( (parts & DurationPart_Hour) == DurationPart_Hour )
			s.append(java.lang.Math.abs(duration.getHour()));
		if(((parts & DurationPart_Hour) == DurationPart_Hour) && ((parts & DurationPart_Minute) == DurationPart_Minute) )
			s.append(":");
		if( (parts & DurationPart_Minute) == DurationPart_Minute )
			s.append(java.lang.Math.abs(duration.getMinute()));
		if(((parts & DurationPart_Minute) == DurationPart_Minute) && ((parts & DurationPart_Second) == DurationPart_Second) )
			s.append(":");
		
		if( (parts & (DurationPart_Second)) == (DurationPart_Second) ) {
			s.append(java.lang.Math.abs(duration.getSecond()));				
		} 
		if( (parts & (DurationPart_Fraction)) == (DurationPart_Fraction) ) {
			double seconds = java.lang.Math.abs(duration.getPartSecond());
			DecimalFormatSymbols symbols = new DecimalFormatSymbols(java.util.Locale.US);
			DecimalFormat formatter = new DecimalFormat("0.0###############", symbols);
			s.append(formatter.format(seconds).substring(1));
		}
		
		command.bindParameter(s.toString());
	}
	
	public static java.sql.Connection newConnection(String url, String user, String password) throws Exception
	{
		return java.sql.DriverManager.getConnection(url, user, password);
	}
	
	public static void addParameter(Statement command, int type, int length)
	{
		command.addParameter(type, length);
	}
	
	public static void prepareStatement(Statement command)
	{
	}
	
	public static void storeStatement(Statement command)
	{
	}
	
	public static Statement newStatement(Catalog catalog, int id, String statement) throws Exception
	{
		statement = statement.trim();
		java.sql.DatabaseMetaData meta = catalog.getConnection().getMetaData(); 
		boolean stripSemicolon = meta.getDriverName().startsWith("IBM DB2 JDBC");
		if( stripSemicolon && statement.endsWith(";") ) 
		{// remove trailing statement end character (DB2: SQL0104N) 
			statement = statement.substring(0,statement.length()-1);
		}
		return catalog.createStatement(id, statement);
	}
	
	public static Statement newQuery(Catalog catalog, int id)
	{
		Statement statement = catalog.getStatement(id);
		statement.clear();
		return statement;
	}
	
	public static ResultSetWrapper executeQuery(Statement query) throws Exception
	{
		return query.execute();
	}

	public static int executeNonReader(Statement query) throws Exception
	{
		return query.executeNonReader();
	}
		
	static public Record newRecord()
	{
		return new Record();
	}
	
	static public boolean moveNextRecord(ResultSetWrapper recordset) throws Exception
	{
		return recordset.getResultSet().next();
	}
	
	static public void disposeRecordset(ResultSetWrapper recordset) throws Exception
	{
		recordset.close();
	}
	
	public static void disposeQuery(Statement query) throws Exception
	{
		query.close();
	}
	
	public static IEnumerable readRecordSet( ResultSetWrapper recordset, SequenceFactory lambda)
	{
		class TResult implements IEnumerable
		{
			class Enumerator implements IEnumerator
			{
				ResultSetWrapper recordset;
				SequenceFactory lambda;
				Object current;
				int pos;
				
				public Enumerator(ResultSetWrapper rs, SequenceFactory y)
				{
					recordset = rs;
					lambda = y;
				}
				
				public boolean moveNext() throws Exception 
				{
					if(recordset.resultset != null)
					{
						if(recordset.resultset.next())
						{
							current = Core.first((IEnumerable) lambda.invoke(recordset));
							pos++;
							return true;
						}
					}
					return false;
				}
				
				public Object current() 
				{
					return current;
				}

				public int position() 
				{
					return pos;
				}

				public void close() 
				{	try
					{
						recordset.close();
					}
					catch (Exception e)
					{
					}
				}
			}
			
			ResultSetWrapper recordset;
			SequenceFactory lambda;
			boolean firsttime = true;
			
			public TResult(ResultSetWrapper rs, SequenceFactory y)
			{
				recordset = rs;
				lambda = y;
			}

			public IEnumerator enumerator() throws Exception 
			{
				if(firsttime) { firsttime = false; return new Enumerator(recordset, lambda); }
				
				recordset.statement.prepare();
				recordset = recordset.statement.execute();
				return new Enumerator(recordset, lambda);
			}
		}
		
		return new TResult(recordset, lambda);
	}
	
	// KBFs
	
	public static void read_boolean(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object object = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Boolean value = null;
		if( object instanceof Boolean )
		{
			value = (Boolean) object;
		}
		else if( object instanceof String )
		{
			String s = (String)object;
			boolean b = s.equalsIgnoreCase("true")
					||	s.equalsIgnoreCase("yes")
					||	s.equalsIgnoreCase("1");
			value = Boolean.valueOf(b);
		}

		record.fields.put(name, new MFSingletonSequence(value.booleanValue()));
	}
	
	public static void read_byte(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object object = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}

		int intValue = 0;
		if( object instanceof Number )
			intValue = ((Number)object).intValue();
		else
		if( object instanceof Boolean )
			intValue = ((Boolean)object) ? 1 : 0;

		record.fields.put(name, new MFSingletonSequence(intValue));
	}
	
	private static long internal_read_year_MySQL( java.sql.ResultSet resultSet, int column, java.util.Date value ) throws Exception
	{
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTime(value); // assign given date
		long year = cal.get(java.util.Calendar.YEAR);

		java.sql.ResultSetMetaData meta = resultSet.getMetaData();
		if( meta != null && meta.getPrecision(column+1) == 2 )
			year -= (year >= 2000 ? 2000 : 1900);
		
		return year;
	}
	
	public static void read_longtext_MYSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = null;
		java.sql.ResultSet resultSet = recordset.getResultSet();
		if( checkForJdbcOdbcResultSet(resultSet) && (resultSet.getMetaData().getPrecision(column+1) < 0) ) {
			java.io.Reader r = resultSet.getCharacterStream(column+1);
		  	if( r != null && !resultSet.wasNull() ) {
				int c=0;
				java.lang.StringBuilder sb = new StringBuilder(); 
				while( (c=r.read()) != -1 ) sb.appendCodePoint(c);
				str = sb.length() > 0 ? sb.toString() : null;
		  	}
		} else { 
			str = resultSet.getString(column+1);
		}
		
		if (resultSet.wasNull() || str == null )
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(str));
	}
	
	public static void read_short(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet(); 
		Object value = resultSet.getObject(column+1);

		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}

		if( value instanceof Number )
		{
			record.fields.put(name, new MFSingletonSequence(((Number)value).intValue()));
			return;
		}
		if( value instanceof java.util.Date )
		{
			Long year = internal_read_year_MySQL( resultSet, column, (java.util.Date)value );
			record.fields.put(name, new MFSingletonSequence( year.intValue() ));
			return;
		}
		
		// error
	}
	
	public static void read_int(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value.intValue()));
	}
	
	public static void read_long(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull() || value == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value.longValue()));
	}
	
	public static void read_float(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		// MapForce strictly uses type double for internal operations
		record.fields.put(name, new MFSingletonSequence(value.doubleValue()));
	}
	
	public static void read_double(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull() || value == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value.doubleValue()));
	}
	
	public static void read_BigDecimal(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		BigDecimal numeric = null;
		if( value instanceof BigDecimal ) { numeric = (BigDecimal)(value); }
		else { numeric = new BigDecimal( value.doubleValue() ); }
		record.fields.put(name, new MFSingletonSequence(numeric));
	}
	
	public static void read_BigInteger(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		BigInteger value = (BigInteger) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_Date(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime(record, recordset, name, column);
	}
	
	public static void read_DateTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		DateTime value = null;
		
		if (obj instanceof java.sql.Timestamp)
			value = timestampToDateTime((java.sql.Timestamp)obj);
			
		if(obj instanceof java.sql.Date)
			value = timestampToDateTime((java.sql.Date) obj);
		
		if(obj instanceof java.sql.Time)
			value = timestampToDateTime((java.sql.Time) obj);

		if(obj instanceof java.lang.String)
			value = DateTime.parse((java.lang.String) obj);
		
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(str));
	}
	
	public static void read_binary(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(column+1);
		
		if (recordset.getResultSet().wasNull() || blob == null) 
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(blob));
	}
	
	public static void read_blob(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_binary(record, recordset, name, column);
	}

	public static void read_binary_MySQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.io.InputStream is = recordset.getResultSet().getBinaryStream(column+1);
		java.io.ByteArrayOutputStream os = new java.io.ByteArrayOutputStream();
		
		if( is != null )
		{
			int v;
			while( (v = is.read()) != -1 )
				os.write(v);
		}
		
		byte[] blob = os.toByteArray(); 

		if( (recordset.getResultSet().wasNull()) || (blob.length == 0) ) 
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}

		record.fields.put(name, new MFSingletonSequence(blob));
	}
	
	public static void read_year_MySQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet(); 
		Object value = resultSet.getObject(column+1);
		
		if (resultSet.wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		if( value instanceof Number )
		{
			long year = ((Number)value).longValue();
			record.fields.put(name, new MFSingletonSequence(year));
			return;
		}

		if( value instanceof java.util.Date )
		{
			long year = internal_read_year_MySQL( resultSet, column, (java.util.Date)value);
			record.fields.put(name, new MFSingletonSequence(year));
			return;
		}

		// error
	}
	
	public static void read_String_ParseDate(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		DateTime value = new DateTime();
		value.parseDate(str.trim());
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		DateTime value = new DateTime();// 24:00:00 = 00:00:00
		value.parseDateTime(str.trim(),DateTime.DateTimePart_Time);
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseTimeTZ_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		int optional = CalendarBase.DateTimePart_TimezoneMinute;

		DateTime value = new DateTime();
		value.parseTime(str.trim(), optional);
		record.fields.put(name, new MFSingletonSequence(value));
	}

	public static void read_String_ParseDateTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		DateTime value = new DateTime();
		value.parseDateTime(str.trim(), CalendarBase.DateTimePart_Date | CalendarBase.DateTimePart_Time);
		record.fields.put(name, new MFSingletonSequence(value));
	}

	public static void read_String_ParseDecimal(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		str = str.trim(); // remove any whitespaces
		if( !str.contains("e") || !str.contains("E") )
		{// for non-scientific formatted decimal.
			if( str.contains(".") )
			{// right trim any trailing zeroes and the decimal dot.
				while( (str.length() > 0) && (str.endsWith("0")) )
					str = str.substring(0, str.length()-1);
				if( (str.length() > 0) && (str.endsWith(".")) )
					str = str.substring(0, str.length()-1);
			}
		}
		
		BigDecimal value = new BigDecimal(str);
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseDouble(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Double value = new Double(str.trim());
		record.fields.put(name, new MFSingletonSequence(value));
	}

	public static void read_binary_Bitfield_MySQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(column+1);
		
		if (recordset.getResultSet().wasNull() || blob == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		BigInteger value = new BigInteger( blob ); 
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_long_BuildBigInteger_MySQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		BigInteger value = new BigInteger(obj.toString()); 
		record.fields.put(name, new MFSingletonSequence(value));
	}

	public static void read_DateTimeOffset_SQLServer(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
/*		DateTime value = null;
		if(obj instanceof microsoft.sql.DateTimeOffset)
		{			
			microsoft.sql.DateTimeOffset dt = (microsoft.sql.DateTimeOffset)obj;
			java.sql.Timestamp ts = dt.getTimestamp(); 
			java.util.TimeZone tz = java.util.TimeZone.getDefault();
			int dst = tz.useDaylightTime() && tz.inDaylightTime(ts) ? tz.getDSTSavings() : 0;
			tz.setRawOffset( (dt.getMinutesOffset() * 60000) - dst );
			java.util.Calendar cal = java.util.Calendar.getInstance(tz);
			cal.set(java.util.Calendar.ZONE_OFFSET, 0);
			cal.setTimeInMillis(ts.getTime());
			
			value = new com.altova.types.DateTime(cal);
			value.setHasTimezone(DateTime.TZ_OFFSET);
			value.setTimezoneOffset(dt.getMinutesOffset());
		} 
*/
		DateTime value = new DateTime();
		java.lang.String s = obj.toString(); 
		java.lang.String[] part = s.split(" ");
		s = part[0] + "T" + part[1] + part[2];
		value.parseDateTime(s, DateTime.DateTimePart_Date | DateTime.DateTimePart_Time);

		record.fields.put(name, new MFSingletonSequence(value));
	}

	public static void read_Decimal_Oracle(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number number = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}	
		
		BigDecimal value = null;
		if( number instanceof BigDecimal )
			value = (BigDecimal)(number);
		else
			value = BigDecimal.valueOf(number.doubleValue());
		
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_double_Oracle(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		double d = 0.0;
		if( value instanceof Float )
		{// avoid rounding issues (binary float)
			String s = ((Float)(value)).toString();
			d = Double.valueOf(s).doubleValue();
		}
		else { d = value.doubleValue(); }
		record.fields.put(name, new MFSingletonSequence(d));
	}

	public static void read_long_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object value = recordset.getResultSet().getLong(column+1);
		
		if (recordset.getResultSet().wasNull() || value == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		if((checkForJdbcOdbcResultSet(recordset.getResultSet())) // fix rounding error
		&& (value instanceof java.lang.Long) && (((Long)(value)).longValue()== java.lang.Long.MIN_VALUE) )
			value = new java.lang.Long(java.lang.Long.MIN_VALUE+1);// -9223372036854775807
		
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_Object_IntervalYearToMonth_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		if( (obj != null) && (obj.getClass().getName().equals("com.informix.lang.IntervalYM")) ) {
			java.lang.reflect.Method method = obj.getClass().getMethod("getMonths", (Class<?>[])(null));
			Long months = (Long)(method.invoke(obj, (Object[])(null))); 					
			
			int y = (int)(months/12);
	        int m = (int)(months%12);
	    
	        boolean positive = true;
	        if( y < 0 || m < 0 ) { 
	        	positive = false;
	        	y = Math.abs(y);
	        	m = Math.abs(m);
	        }
	        
			Duration duration = new Duration(y, m, 0, 0, 0, 0, 0.0, !positive );
			record.fields.put(name, new MFSingletonSequence(duration));
		}
		else
		{
			read_String_ParseIntervalYearToMonth_Informix(record, recordset, name, column);
		}
	}
	
	public static void read_String_ParseIntervalYearToMonth_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_String_ParseIntervalYearToMonth(record, recordset, name, column);
	}

	public static void read_Object_IntervalYearToMonth_Oracle(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		//if( obj instanceof oracle.sql.INTERVALYM ) {
		//	oracle.sql.INTERVALYM ym = (oracle.sql.INTERVALYM)(obj);
		//	byte[] paramArrayOfByte = ym.toBytes();
		if( (obj != null) && (obj.getClass().getName().equals("oracle.sql.INTERVALYM")) ) {
			java.lang.reflect.Method method = obj.getClass().getMethod("toBytes", (Class<?>[])(null));
			byte[] paramArrayOfByte = (byte[])(method.invoke(obj, (Object[])(null))); 					
			
			int INTYMYEAROFFSET = -2147483648;
			int INTYMMONTHOFFSET = 60;
			
			int j  = (paramArrayOfByte[0] & 0xFF) << 24;
	        	j |= (paramArrayOfByte[1] & 0xFF) << 16;
	        	j |= (paramArrayOfByte[2] & 0xFF) << 8;
	        	j |= (paramArrayOfByte[3] & 0xFF);
	        	j -= INTYMYEAROFFSET;

	        int k = paramArrayOfByte[4] - INTYMMONTHOFFSET;	
	    
	        boolean positive = true;
	        if( j < 0 || k < 0 ) { 
	        	positive = false;
	        	j = Math.abs(j);
	        	k = Math.abs(k);
	        }
	        
			Duration duration = new Duration(j, k, 0, 0, 0, 0, 0.0, !positive );
			record.fields.put(name, new MFSingletonSequence(duration));
		}
		else
		{
			read_String_ParseIntervalYearToMonth_Oracle(record, recordset, name, column);
		}
	}
	
	public static void read_String_ParseIntervalYearToMonth_Oracle(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_String_ParseIntervalYearToMonth(record, recordset, name, column);
	}
	
	public static void read_String_ParseIntervalYearToMonth(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Duration.RefInt n = new Duration.RefInt(0);
		str = str.trim(); // strip leading/trailing whitespaces
		CalendarBase.ParseContext context = new Duration.ParseContext(str);
		String err = str + " cannot be converted to a duration value.";
		
		boolean positive = true; // parse sign
		if( context.checkAndAdvance('-') ) positive = false;
		else if( context.checkAndAdvance('+') ) positive = true;
		//else throw new StringParseException(err + "Invalid or missing sign.",2);
		if (!context.isValid()) throw new StringParseException(err,2);

		int years = 0; // parse year component
		while(context.readDigitAndAdvance(n, 1, 9)) { years = (years * 10) + n.value; n.value = 0; }

		// check year-month divider
		if (!context.isValid()) throw new StringParseException(err + "Missing year-month divider.",2);
		if (!context.checkAndAdvance('-')) throw new StringParseException(err + "Invalid year-month divider.",2);
		if (!context.isValid()) throw new StringParseException(err + "Missing month value.",2);

		int month = 0;// parse month component
		while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }

		Duration duration = new Duration(years, month, 0, 0, 0, 0, 0.0, !positive );
		record.fields.put(name, new MFSingletonSequence(duration));
	}
	

	public static void read_Object_IntervalDayToSecond_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		if( (obj != null) && (obj.getClass().getName().equals("com.informix.lang.IntervalDF")) ) {
			java.lang.reflect.Method methodGetSeconds = obj.getClass().getMethod("getSeconds", (Class<?>[])(null));
			Long seconds = (Long)(methodGetSeconds.invoke(obj, (Object[])(null)));
			java.lang.reflect.Method methodGetNanoSeconds = obj.getClass().getMethod("getNanoSeconds", (Class<?>[])(null));
			Long nanos = (Long)(methodGetNanoSeconds.invoke(obj, (Object[])(null)));
			
			int d = (int)((seconds / (60*60*24)));
			int h = (int)((seconds / (60*60)) % 24);
			int m = (int)((seconds / 60) % 60);
			int s = (int)(seconds % 60);
			int n = (int)(nanos.intValue());
			
			boolean positive = true;
	        if (d < 0 || h < 0 || m < 0 || s < 0 || n < 0) {
	        	positive = false;
	            d = Math.abs(d);
	            h = Math.abs(h);
	            m = Math.abs(m);
	            s = Math.abs(s);
	            n = Math.abs(n);
	        }
			
			double nano = 1000.0*1000.0*1000.0;
	        double frac = n/nano;// nano to sec
	        //double sec = s + frac;
	        
			Duration duration = new Duration(0, 0, d, h, m, s, frac, !positive );
			record.fields.put(name, new MFSingletonSequence(duration));
		}
		else
		{
			read_String_ParseIntervalDayToSecond_Informix(record, recordset, name, column);
		}	
	}
		
	public static void read_String_ParseIntervalDayToSecond_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_String_ParseIntervalDayToSecond(record, recordset, name, column);
	}

	public static void read_Object_IntervalDayToSecond_Oracle(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		//if( obj instanceof oracle.sql.INTERVALDS ) {
		//	oracle.sql.INTERVALDS ds = (oracle.sql.INTERVALDS)(obj);
		//	byte[] paramArrayOfByte = ds.toBytes();
		if( (obj != null) && (obj.getClass().getName().equals("oracle.sql.INTERVALDS")) ) {
			java.lang.reflect.Method method = obj.getClass().getMethod("toBytes", (Class<?>[])(null));
			byte[] paramArrayOfByte = (byte[])(method.invoke(obj, (Object[])(null)));

			int INTERVALDSOFFSET = 60;
			int INTERVALDAYOFFSET = -2147483648;

			int d  = (paramArrayOfByte[0] & 0xFF) << 24;
	        	d |= (paramArrayOfByte[1] & 0xFF) << 16;
	        	d |= (paramArrayOfByte[2] & 0xFF) << 8;
	        	d |= (paramArrayOfByte[3] & 0xFF);
	        	d -= INTERVALDAYOFFSET;

			int h = paramArrayOfByte[4] - INTERVALDSOFFSET;
	        int m = paramArrayOfByte[5] - INTERVALDSOFFSET;
	        int s = paramArrayOfByte[6] - INTERVALDSOFFSET;

			int n  = (paramArrayOfByte[7] & 0xFF) << 24;
				n |= (paramArrayOfByte[8] & 0xFF) << 16;
				n |= (paramArrayOfByte[9] & 0xFF) << 8;
				n |= (paramArrayOfByte[10] & 0xFF);
				n -= INTERVALDAYOFFSET;

			boolean positive = true;
	        if (d < 0 || h < 0 || m < 0 || s < 0 || n < 0) {
	        	positive = false;
	            d = Math.abs(d);
	            h = Math.abs(h);
	            m = Math.abs(m);
	            s = Math.abs(s);
	            n = Math.abs(n);
	        }

	        double nano = 1000.0*1000.0*1000.0;
	        double frac = n/nano;// nano to sec
	        double sec = s + frac;
	        
			Duration duration = new Duration(0, 0, d, h, m, s, frac, !positive );
			record.fields.put(name, new MFSingletonSequence(duration));
		}
		else
		{
			read_String_ParseIntervalDayToSecond_Oracle(record, recordset, name, column);
		}
	}
	
	public static void read_String_ParseIntervalDayToSecond_Oracle(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_String_ParseIntervalDayToSecond(record, recordset, name, column);
	}
	
	public static void read_String_ParseIntervalDayToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Duration.RefInt n = new Duration.RefInt(0); 
		str = str.trim(); // strip leading/trailing whitespaces
		CalendarBase.ParseContext context = new Duration.ParseContext(str);
		String err = str + " cannot be converted to a duration value.";
		
		boolean positive = true; // parse sign
		if( context.checkAndAdvance('-') ) positive = false;
		else if( context.checkAndAdvance('+') ) positive = true;
		//else throw new StringParseException(err,2);
		if (!context.isValid()) throw new StringParseException(err,2);

		int days = 0; // parse day component
		while(context.readDigitAndAdvance(n, 1, 9)) { days = (days * 10) + n.value; n.value = 0; }
		if (!context.isValid()) throw new StringParseException(err,2);

		// check days-time divider
		if (!context.checkAndAdvance(' ')) throw new StringParseException(err,2);
		if (!context.isValid()) throw new StringParseException(err,2);

		String isotime = str.substring( context.index() );// parse hours:minutes:seconds.fraction 
		DateTime time = new DateTime();
		time.parseTime(isotime);
 
		Duration duration = new Duration(0, 0, days, time.getHour(), time.getMinute(), time.getSecond(), time.getMillisecond()/1000.0, !positive );
		record.fields.put(name, new MFSingletonSequence(duration));
	}
	
	public static void read_Object_Interval_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		//if( obj instanceof org.postgresql.util.PGInterval ) {
		//	org.postgresql.util.PGInterval interval = (org.postgresql.util.PGInterval)(obj);
		//	int year = interval.getYears();
		//	int month = interval.getMonths();
		//	int day = interval.getDays();
		//	int hour = interval.getHours();
		//	int minute = interval.getMinutes();
		//	double s = interval.getSeconds();
		if( (obj != null) && (obj.getClass().getName().equals("org.postgresql.util.PGInterval")) ) {
			Object[] a = null;
			Class<?>[] v = null;
			Class<?> c = obj.getClass();
			int year = ((Integer)(c.getMethod("getYears", v).invoke(obj, a))).intValue(); 					
			int month = ((Integer)(c.getMethod("getMonths", v).invoke(obj, a))).intValue(); 					
			int day = ((Integer)(c.getMethod("getDays", v).invoke(obj, a))).intValue(); 					
			int hour = ((Integer)(c.getMethod("getHours", v).invoke(obj, a))).intValue(); 					
			int minute = ((Integer)(c.getMethod("getMinutes", v).invoke(obj, a))).intValue(); 					
			double s = ((Double)(c.getMethod("getSeconds", v).invoke(obj, a))).doubleValue(); 					
			int second = (int)(s);
			double fraction = s - second;
			boolean positive = (year>=0) && (month>=0) && (day>=0) && (hour>=0) && (minute>=0) && (second>=0) && (fraction>=0.0);
			if(!positive) {
				year = -Math.abs(year);
				month = -Math.abs(month);
				day = -Math.abs(day);
				hour = -Math.abs(hour);
				minute = -Math.abs(minute);
				second = -Math.abs(second);
				fraction = -Math.abs(fraction);
			}
			Duration duration = new Duration(year, month, day, hour, minute, second, fraction, !positive );
			record.fields.put(name, new MFSingletonSequence(duration));
		}
		else
		{
			read_String_ParseInterval_PostgreSQL(record, recordset, name, column);
		}
	}
	
	public static void read_String_ParseInterval_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		
		// Format: YYYY/MM/DD/hh/mm/ss.ff9

		boolean positive = true;
		double fraction = 0.0;

		Duration.RefInt n = new Duration.RefInt(0); 
		CalendarBase.ParseContext context = new Duration.ParseContext(str.trim());
		String err = str + " cannot be converted to a duration value.";

		int years = 0; // parse year component
		if( context.checkAndAdvance('-') ) positive = false;
		if (!context.isValid()) throw new StringParseException(err,2);
		while(context.readDigitAndAdvance(n, 1, 9)) { years = (years * 10) + n.value; n.value = 0; }
		if (!context.isValid()) throw new StringParseException(err,2);

		if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);
		
		int month = 0; // parse month component
		if( context.checkAndAdvance('-') ) positive = false;
		if (!context.isValid()) throw new StringParseException(err,2);
		while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }
		if (!context.isValid()) throw new StringParseException(err,2);
		
		if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);

		int days = 0; // parse days component
		if( context.checkAndAdvance('-') ) positive = false;
		if (!context.isValid()) throw new StringParseException(err,2);
		while(context.readDigitAndAdvance(n, 1, 9)) { days = (days * 10) + n.value; n.value = 0; }
		if (!context.isValid()) throw new StringParseException(err,2);
		
		if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);

		int hours = 0; // parse hour component
		if( context.checkAndAdvance('-') ) positive = false;
		if (!context.isValid()) throw new StringParseException(str,2);
		while(context.readDigitAndAdvance(n, 1, 9)) { hours = (hours * 10) + n.value; n.value = 0; }
		if (!context.isValid()) throw new StringParseException(str,2);

		if(!context.checkAndAdvance('/')) throw new StringParseException(str,2);

		int minutes = 0; // parse minute component
		if( context.checkAndAdvance('-') ) positive = false;
		if (!context.isValid()) throw new StringParseException(str,2);
		while(context.readDigitAndAdvance(n, 1, 9)) { minutes = (minutes * 10) + n.value; n.value = 0; }
		if (!context.isValid()) throw new StringParseException(str,2);

		if(!context.checkAndAdvance('/')) throw new StringParseException(str,2);

		int seconds = 0; // parse seconds component
		if( context.checkAndAdvance('-') ) positive = false;
		if (!context.isValid()) throw new StringParseException(str,2);
		while(context.readDigitAndAdvance(n, 1, 9)) { seconds = (seconds * 10) + n.value; n.value = 0; }
		if(!context.isValid()) throw new StringParseException(str,2);
		if( context.checkAndAdvance('.') )
		{
			int temp = 0; // microseconds
			if(!context.isValid()) throw new StringParseException(str,2);
			while (context.readDigitAndAdvance(n, 1, 9)) { temp = (temp * 10) + n.value; n.value = 0; }
			fraction = temp / 1000000.0;
		}
		
		Duration duration = new Duration(years, month, days, hours, minutes, seconds, fraction, !positive );
		record.fields.put(name, new MFSingletonSequence(duration));
	}

	public static void read_money_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		ResultSet resultSet = recordset.getResultSet(); 
		if( checkForJdbcOdbcResultSet(resultSet) )
		{// the jdbc odbc bridge correctly converts money types
			read_double( record, recordset, name, column);
			return;
		}

		// when using the PostgreSQL JDBC Interface
		String str = resultSet.getString(column+1);
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}

		java.util.Locale locale = java.util.Locale.US; //java.util.Locale.getDefault();
		java.text.NumberFormat format = java.text.NumberFormat.getCurrencyInstance(locale);
		double value = format.parse( str ).doubleValue();
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	private static String internalFormatGUID(byte[] bytes)
	{	
		if( (bytes == null) || ((bytes != null) && bytes.length == 0) ) 
			return null; // sanity check
		
		byte[] hexchars = {
			'0', '1', '2', '3', '4', '5',
			'6', '7', '8', '9', 'a', 'b',
			'c', 'd', 'e', 'f'
		};
		Boolean curly = true;
		int n = (2 * bytes.length) + 4 + (curly ? 2 : 0);
		StringBuilder s = new StringBuilder(n);
		if( curly ) s.append('{');//prefix
		for (int i = 0; i < bytes.length; i++) 
		{
			int v = bytes[i] & 0xff;
			s.append((char)hexchars[v >> 4]);
			s.append((char)hexchars[v & 0xf]);
			if( i==3 || i==5 || i==7 || i==9)
				s.append('-');//separator 
		}
		if( curly ) s.append('}');//suffix
		return s.toString().toUpperCase();			
	}

	public static boolean checkForJdbcOdbcConnection( java.sql.Connection connection ) throws Exception
	{
	//	return (connection instanceof sun.jdbc.odbc.JdbcOdbcConnection);// not for linux
		return (connection.getClass().getName().equals("sun.jdbc.odbc.JdbcOdbcConnection"));
	}

	public static boolean checkForJdbcOdbcResultSet( java.sql.ResultSet resultSet ) throws Exception
	{
	//	return (resultSet instanceof sun.jdbc.odbc.JdbcOdbcResultSet);// not for linux
		return (resultSet.getClass().getName().equals("sun.jdbc.odbc.JdbcOdbcResultSet"));
	}
	
	public static void read_binary_BuildGuidString(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(column+1);
		
		if (recordset.getResultSet().wasNull() || blob == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		byte[] buf = new byte[8];
		
		buf[0] = blob[3];	buf[1] = blob[2];	buf[2] = blob[1];	buf[3] = blob[0];
		buf[4] = blob[5];	buf[5] = blob[4];	buf[6] = blob[7];	buf[7] = blob[6];

		blob[0] = buf[0];	blob[1] = buf[1];	blob[2] = buf[2];	blob[3] = buf[3];
		blob[4] = buf[4];	blob[5] = buf[5];	blob[6] = buf[6];	blob[7] = buf[7];

		String value = internalFormatGUID( blob );
		record.fields.put(name, new MFSingletonSequence(value));
	}

	public static void read_string_BuildGuidString(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String value = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		if( !value.startsWith("{")) value = "{" + value;
		if( !value.endsWith("}")) value = value + "}";
		record.fields.put(name, new MFSingletonSequence(value.toUpperCase()));
	}

	public static void read_String_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		str = str.replaceAll("\\r\\n", "\n");
		record.fields.put(name, new MFSingletonSequence(str));
	}
	
	public static void read_uuid_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		if( checkForJdbcOdbcResultSet(resultSet) )
		{// when using the JdbcOdbc bridge, read as binary and convert to guid  
			com.altova.db.Dbs.read_binary_BuildGuidString(record, recordset, name, column);
		}
		else
		{// native driver such as "PostgreSQL X.Y JDBC4" must read as string 
			com.altova.db.Dbs.read_string_BuildGuidString(record, recordset, name, column);
		}
	}
	
	public static void read_int_Boolean_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence((boolean)(value.intValue()!=0)));
	}
	
	public static void read_DateTimeTZ_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		if( checkForJdbcOdbcResultSet(recordset.getResultSet()) ) {
			read_DateTime(record, recordset, name, column);
			return;
		}
		
		String str = recordset.getResultSet().getString(column+1);
		if (recordset.getResultSet().wasNull() || str == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}

		// "YYYY-MM-DD hh:mm:ss.fff+TH"
		String datePart = str.substring(0, str.indexOf(" "));
		str = str.substring(datePart.length()).trim();
		int timeEnd = str.indexOf("+") != -1 ? str.indexOf("+")
					: str.indexOf("-") != -1 ? str.indexOf("-")
					: str.length();
		String timePart = str.substring(0, timeEnd);
		String zonePart = str.substring(timeEnd).trim();
		if(zonePart.indexOf(":") == -1) zonePart += ":00";
		
		DateTime dt = new com.altova.types.DateTime();
		dt.parseDate(datePart);
		dt.parseTime(timePart + zonePart);
		record.fields.put(name, new MFSingletonSequence(dt));
	}
	
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, int column, String charsetName ) throws Exception
	{
		return internal_read_unicodestring( resultSet, column, java.nio.charset.Charset.forName(charsetName) );
	}
		
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, int column, java.nio.charset.Charset charset ) throws Exception
	{
		java.io.InputStream stream = resultSet.getBinaryStream(column+1);
		java.io.InputStreamReader reader = (stream != null) ? new java.io.InputStreamReader(stream,charset) : null;
		return internal_read_unicodestring( resultSet, reader );
	}
	
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, java.io.InputStream stream ) throws Exception
	{
		java.io.InputStreamReader reader = (stream != null) ? new java.io.InputStreamReader(stream) : null;
		return internal_read_unicodestring( resultSet, reader );
	}
	
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, java.io.Reader reader ) throws Exception
	{
		String content = null;
		if( reader != null )
		{
			java.io.StringWriter writer = new java.io.StringWriter();
			
			int v,n;//build graphic string, count size
			for( n=0; (v = reader.read()) != -1; ++n )
				writer.write(v);

			writer.flush();// finalize writer
			
			if( !(resultSet.wasNull()) && (n == 0) )
			{// value is an empty string
				content = new String("");  
			}
			else
			if( !(resultSet.wasNull()) && (n > 0))  
			{
				content = writer.toString();
			}
		}
		
		return content;
	}

	public static void read_Unicode_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		byte[] bytes = resultSet.getBytes(column+1);

		if (resultSet.wasNull() || bytes == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		String content = new String(bytes, "UTF-8");
		record.fields.put(name, new MFSingletonSequence(content));
	}

	public static void read_Xml_PostgreSQL(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		String content = internal_read_unicodestring( resultSet, column, "UTF-8" );
		if (resultSet.wasNull() || content == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		content = content.replace("\r\n", "\n");
		record.fields.put(name, new MFSingletonSequence(content));
	}

	public static void read_ntext_SQLServer(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		if( !(checkForJdbcOdbcResultSet(resultSet)) )
		{// any other result set kind - simply read the string content
			com.altova.db.Dbs.read_String(record, recordset, name, column);
			return; // done
		}

		byte[] bytes = resultSet.getBytes(column+1);
		if (resultSet.wasNull() || bytes == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		String content = new String(bytes,"UTF-16LE") ;
		record.fields.put(name, new MFSingletonSequence(content));
	}
	
	public static void read_ntext_Sybase(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		if( checkForJdbcOdbcResultSet(resultSet) )
		{// when using the jdbc odbc bridge ...
			com.altova.db.Dbs.read_String(record, recordset, name, column);
			return; // done
		}
	
		java.io.InputStream reader = resultSet.getAsciiStream(column+1);
		String content = internal_read_unicodestring( resultSet, reader );
		if (resultSet.wasNull() || content == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(content));
	}	

	public static void read_DateTime_Sybase(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		java.sql.Timestamp ts = (java.sql.Timestamp)obj;
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTimeInMillis(ts.getTime());
		DateTime value = new com.altova.types.DateTime(cal);
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_Clob_DB2(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		if( !(checkForJdbcOdbcResultSet(resultSet)) )
		{// any other result set kind - simply read the string content
			com.altova.db.Dbs.read_String(record, recordset, name, column);
			return; // done
		}

		byte[] bytes = resultSet.getBytes(column+1);
		if (resultSet.wasNull() || bytes == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		String content = new String(bytes,"UTF-8") ;
		record.fields.put(name, new MFSingletonSequence(content));
	}
	
	public static void read_DbClob_DB2(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		if( !(checkForJdbcOdbcResultSet(resultSet)) )
		{// any other result set kind - simply read the string content
			com.altova.db.Dbs.read_String(record, recordset, name, column);
			return; // done
		}

		byte[] bytes = resultSet.getBytes(column+1);
		if (resultSet.wasNull() || bytes == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		String content = new String(bytes,"UTF-16BE") ;
		record.fields.put(name, new MFSingletonSequence(content));
	}

	public static void read_Graphic_DB2(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DbClob_DB2(record,recordset,name, column);
	}

	public static void read_clob_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		if( !(checkForJdbcOdbcResultSet(resultSet)) )
		{// any other result set kind - simply read the string content
			com.altova.db.Dbs.read_String(record, recordset, name, column);
			return; // done
		}

		byte[] bytes = resultSet.getBytes(column+1);
		if (resultSet.wasNull() || bytes == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		String content = new String(bytes,"UTF-8") ;
		record.fields.put(name, new MFSingletonSequence(content));
	}

	public static void read_decimal_Informix(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet();
		BigDecimal value = resultSet.getBigDecimal(column+1);
		if (resultSet.wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	// Helper functions
	
	private static com.altova.types.DateTime timestampToDateTime(java.util.Date ts)
	{
		if (ts == null)
			return null;
			
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTimeInMillis(ts.getTime());
		return new com.altova.types.DateTime(cal);
	}

	private static com.altova.types.DateTime timestampToDateTime(java.sql.Timestamp ts)
	{
		if (ts == null)
			return null;
			
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTimeInMillis(ts.getTime());
		com.altova.types.DateTime val = new com.altova.types.DateTime(cal);
		val.setPartSecond( ts.getNanos() / 1000000000.0 );
		return val; 
	}
}
